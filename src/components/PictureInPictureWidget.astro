---
// Direct Picture-in-Picture Countdown Component
---

<style>
  /* PiP Canvas Styles */
  #pip-canvas {
    background: linear-grad<!-- Mobile fallback notification -->
<div id="pip-fallback" class="pip-fallback">
  <div style="margin-bottom: 6px; font-weight: 500; display: flex; align-items: center; gap: 6px;">
    <span>üì±</span>
    <span>Picture-in-Picture not available</span>
  </div>
  <div style="font-size: 11px; opacity: 0.7;">Use a desktop browser for PiP countdown experience</div>
</div>135deg, #ffffff 0%, #f4f4f5 50%, #ffffff 100%);
    font-family: 'Inter', sans-serif;
    border-radius: 8px;
    box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
  }

  /* PiP Status Indicator */
  .pip-status {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(255, 255, 255, 0.95);
    color: #374151;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 500;
    z-index: 1001;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    display: none;
    align-items: center;
    gap: 6px;
    transition: all 0.3s ease;
    font-family: 'Inter', sans-serif;
  }

  .pip-status.active {
    display: flex;
    animation: slideIn 0.3s ease;
  }

  .pip-indicator {
    width: 6px;
    height: 6px;
    background: #10b981;
    border-radius: 50%;
    animation: pulse 2s infinite;
  }

  .pip-close-btn {
    background: none;
    border: none;
    color: #6b7280;
    cursor: pointer;
    padding: 2px;
    margin-left: 4px;
    border-radius: 4px;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .pip-close-btn:hover {
    color: #374151;
    background: rgba(0, 0, 0, 0.05);
  }

  @keyframes slideIn {
    from {
      opacity: 0;
      transform: translateX(100px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  @keyframes pulse {
    0%, 100% {
      opacity: 1;
      transform: scale(1);
    }
    50% {
      opacity: 0.7;
      transform: scale(1.1);
    }
  }

  /* Mobile fallback notification */
  .pip-fallback {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.95);
    color: #374151;
    padding: 12px 20px;
    border-radius: 8px;
    font-size: 13px;
    text-align: center;
    z-index: 1001;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    max-width: calc(100vw - 40px);
    display: none;
    font-family: 'Inter', sans-serif;
  }

  .pip-fallback.show {
    display: block;
    animation: slideUp 0.3s ease;
  }

  @keyframes slideUp {
    from {
      opacity: 0;
      transform: translate(-50%, 100px);
    }
    to {
      opacity: 1;
      transform: translate(-50%, 0);
    }
  }
</style>

<!-- Hidden canvas for PiP -->
<canvas id="pip-canvas" width="640" height="360" style="display: none;"></canvas>

<!-- PiP Status Indicator -->
<div id="pip-status" class="pip-status">
  <div class="pip-indicator"></div>
  <span id="pip-status-text">Picture-in-Picture Active</span>
  <button onclick="closePiP()" class="pip-close-btn">
    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="18" y1="6" x2="6" y2="18"></line>
      <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
  </button>
</div>

<!-- Mobile fallback notification -->
<div id="pip-fallback" class="pip-fallback">
  <div style="margin-bottom: 6px; font-weight: 500;">ÔøΩ Picture-in-Picture not supported</div>
  <div style="font-size: 11px; opacity: 0.7;">Use a desktop browser for PiP countdown experience</div>
</div>

<script>
// Global type extensions
declare global {
  interface Window {
    pipCountdown: PictureInPictureCountdown;
    startPiPCountdown: (exam: any, session?: any) => void;
    stopPiPCountdown: () => void;
    closePiP: () => void;
  }
}

class PictureInPictureCountdown {
  isActive: boolean;
  currentExam: any;
  currentSession: any;
  updateInterval: number | null;
  canvas: HTMLCanvasElement | null;
  ctx: CanvasRenderingContext2D | null;
  video: HTMLVideoElement | null;
  stream: MediaStream | null;
  serviceWorker: ServiceWorkerRegistration | null;

  constructor() {
    this.isActive = false;
    this.currentExam = null;
    this.currentSession = null;
    this.updateInterval = null;
    this.canvas = null;
    this.ctx = null;
    this.video = null;
    this.stream = null;
    this.serviceWorker = null;
    
    this.init();
  }

  init() {
    // Ensure DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => this.initCanvas());
    } else {
      this.initCanvas();
    }
    
    this.registerServiceWorker();
  }

  initCanvas() {
    this.canvas = document.getElementById('pip-canvas') as HTMLCanvasElement;
    if (this.canvas) {
      this.ctx = this.canvas.getContext('2d');
      
      // Ensure canvas has proper dimensions (16:9 aspect ratio for better PiP experience)
      if (this.canvas.width === 0 || this.canvas.height === 0) {
        this.canvas.width = 640;
        this.canvas.height = 360;
      }
      
      console.log('PiP Canvas initialized:', this.canvas.width, 'x', this.canvas.height);
      
      // Draw a test frame to ensure canvas is ready with the light theme
      if (this.ctx) {
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Add subtle border
        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(0.5, 0.5, this.canvas.width - 1, this.canvas.height - 1);
      }
    } else {
      console.error('PiP Canvas element not found');
    }
  }

  async registerServiceWorker() {
    if ('serviceWorker' in navigator) {
      try {
        const registration = await navigator.serviceWorker.register('/sw.js');
        this.serviceWorker = registration;
        console.log('PiP Service Worker registered successfully');
        
        // Request notification permission
        if ('Notification' in window && Notification.permission === 'default') {
          await Notification.requestPermission();
        }
      } catch (error) {
        console.error('Service Worker registration failed:', error);
      }
    }
  }

  checkSupport(): { supported: boolean; reason?: string } {
    // Check if running on mobile device
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (!('pictureInPictureEnabled' in document)) {
      return { 
        supported: false, 
        reason: isMobile ? 'Picture-in-Picture not available on mobile devices' : 'Browser does not support Picture-in-Picture'
      };
    }
    
    if (!document.pictureInPictureEnabled) {
      return { 
        supported: false, 
        reason: 'Picture-in-Picture is disabled in browser settings. Please enable it to use this feature.'
      };
    }
    
    if (!this.canvas) {
      return { 
        supported: false, 
        reason: 'Canvas element not available. Please refresh the page and try again.'
      };
    }
    
    if (!this.canvas.captureStream) {
      return { 
        supported: false, 
        reason: isMobile ? 'Canvas streaming not supported on this device' : 'Canvas stream capture not supported in this browser'
      };
    }
    
    return { supported: true };
  }

  async startPiP(exam: any, session: any = null) {
    const support = this.checkSupport();
    if (!support.supported) {
      console.warn('Picture-in-Picture not supported:', support.reason);
      this.showFallbackNotification(support.reason);
      return false;
    }

    try {
      this.currentExam = exam;
      this.currentSession = session || (exam.sessions && exam.sessions[0]);
      this.isActive = true;

      // Initialize canvas with countdown content first
      if (!this.canvas || !this.ctx) {
        console.error('Canvas not properly initialized');
        return false;
      }

      // Check for captureStream support
      if (!this.canvas.captureStream) {
        console.error('Canvas captureStream not supported');
        this.showFallbackNotification('Your browser doesn\'t support canvas streaming for Picture-in-Picture');
        return false;
      }

      // Draw initial countdown to ensure canvas has content
      this.updateCountdown();
      
      // Small delay to ensure canvas is rendered
      await new Promise(resolve => setTimeout(resolve, 100));

      // Create video stream from canvas
      if (!this.video) {
        try {
          this.stream = this.canvas.captureStream(30);
          
          // Verify stream has video tracks
          const videoTracks = this.stream.getVideoTracks();
          if (videoTracks.length === 0) {
            throw new Error('No video tracks in canvas stream');
          }
          
          console.log('Canvas stream created with', videoTracks.length, 'video tracks');
          
          this.video = document.createElement('video');
          this.video.srcObject = this.stream;
          this.video.muted = true;
          this.video.autoplay = true;
          this.video.playsInline = true;
          this.video.loop = true;
          
          // Set video dimensions to match canvas
          this.video.width = this.canvas.width;
          this.video.height = this.canvas.height;
          
          console.log('Video element created and configured');
          
          // Wait for video metadata to load before requesting PiP
          await new Promise<void>((resolve, reject) => {
            const timeout = setTimeout(() => {
              reject(new Error('Video metadata loading timeout'));
            }, 8000); // Increased timeout for slower devices
            
            // Multiple event listeners for better compatibility
            const onSuccess = () => {
              console.log('Video metadata loaded, ready for PiP');
              clearTimeout(timeout);
              cleanup();
              resolve();
            };
            
            const onError = (e: any) => {
              console.error('Video error event:', e);
              clearTimeout(timeout);
              cleanup();
              reject(new Error('Video loading error'));
            };
            
            const cleanup = () => {
              this.video!.removeEventListener('loadedmetadata', onSuccess);
              this.video!.removeEventListener('loadeddata', onSuccess);
              this.video!.removeEventListener('canplay', onSuccess);
              this.video!.removeEventListener('error', onError);
            };
            
            this.video!.addEventListener('loadedmetadata', onSuccess, { once: true });
            this.video!.addEventListener('loadeddata', onSuccess, { once: true });
            this.video!.addEventListener('canplay', onSuccess, { once: true });
            this.video!.addEventListener('error', onError, { once: true });
            
            // Start playing the video with additional error handling
            this.video!.play()
              .then(() => {
                console.log('Video playback started');
                // If video starts playing but metadata not loaded yet, wait a bit more
                if (this.video!.readyState < 1) {
                  setTimeout(() => {
                    if (this.video!.readyState >= 1) {
                      onSuccess();
                    }
                  }, 500);
                }
              })
              .catch((playError) => {
                console.error('Video play error:', playError);
                onError(playError);
              });
          });
        } catch (streamError) {
          console.error('Failed to create canvas stream:', streamError);
          throw new Error(`Canvas stream creation failed: ${streamError.message}`);
        }
      }

      // Ensure video is ready for PiP
      if (this.video.readyState < 1) {
        await new Promise<void>((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error('Video not ready for PiP'));
          }, 3000);
          
          this.video!.addEventListener('loadedmetadata', () => {
            clearTimeout(timeout);
            resolve();
          }, { once: true });
        });
      }

      // Start PiP
      await this.video.requestPictureInPicture();
      
      // Status indicator will be shown by the 'enterpictureinpicture' event
      // Start countdown updates
      this.startUpdating();
      
      // Setup service worker background sync
      if (this.serviceWorker && navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({
          type: 'SETUP_BACKGROUND_SYNC',
          data: this.currentSession
        });
      }

      return true;
    } catch (error) {
      console.error('Failed to start Picture-in-Picture:', error);
      console.error('Video ready state:', this.video?.readyState);
      console.error('Video metadata loaded:', this.video?.readyState >= 1);
      console.error('Video duration:', this.video?.duration);
      
      // Clean up on error
      if (this.video) {
        this.video.srcObject = null;
        this.video = null;
      }
      
      if (this.stream) {
        this.stream.getTracks().forEach(track => track.stop());
        this.stream = null;
      }
      
      this.isActive = false;
      
      // Provide specific error messages based on error type
      let errorMessage = 'Failed to start Picture-in-Picture mode';
      if (error.message.includes('not supported')) {
        errorMessage = 'Picture-in-Picture is not supported on this device or browser';
      } else if (error.message.includes('stream')) {
        errorMessage = 'Unable to create video stream for Picture-in-Picture';
      } else if (error.message.includes('timeout')) {
        errorMessage = 'Picture-in-Picture initialization timed out. Please try again.';
      } else if (error.message.includes('permission')) {
        errorMessage = 'Picture-in-Picture permission denied. Please allow PiP in browser settings.';
      }
      
      this.showFallbackNotification(errorMessage);
      return false;
    }
  }

  async stopPiP() {
    try {
      if (document.pictureInPictureElement) {
        await document.exitPictureInPicture();
      }
      
      // Always reset state and hide indicator
      this.isActive = false;
      this.hideStatusIndicator();
      this.stopUpdating();
      
      // Clean up video stream
      if (this.video) {
        this.video.srcObject = null;
        this.video = null;
      }
      
      if (this.stream) {
        this.stream.getTracks().forEach(track => track.stop());
        this.stream = null;
      }
      
      console.log('PiP stopped and cleaned up');
    } catch (error) {
      console.error('Failed to stop Picture-in-Picture:', error);
      // Even if there's an error, make sure we clean up
      this.isActive = false;
      this.hideStatusIndicator();
      this.stopUpdating();
    }
  }

  formatTimeRemaining(targetDate: string) {
    const now = new Date().getTime();
    const target = new Date(targetDate).getTime();
    const distance = target - now;
    
    if (distance < 0) {
      return { expired: true, days: 0, hours: 0, minutes: 0, seconds: 0 };
    }
    
    const days = Math.floor(distance / (1000 * 60 * 60 * 24));
    const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((distance % (1000 * 60)) / 1000);
    
    return { expired: false, days, hours, minutes, seconds };
  }

  updateCountdown() {
    if (!this.currentSession || !this.ctx || !this.canvas) return;

    const timeRemaining = this.formatTimeRemaining(this.currentSession.date);
    
    if (timeRemaining.expired) {
      this.drawExpiredState();
      return;
    }
    
    this.drawCountdown(timeRemaining.days, timeRemaining.hours, timeRemaining.minutes, timeRemaining.seconds);
  }

  drawCountdown(days: number, hours: number, minutes: number, seconds: number) {
    if (!this.ctx || !this.canvas) return;
    
    const width = this.canvas.width;
    const height = this.canvas.height;
    
    // Clear canvas with clean white background
    this.ctx.fillStyle = '#ffffff';
    this.ctx.fillRect(0, 0, width, height);
    
    // Add subtle border
    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
    this.ctx.lineWidth = 1;
    this.ctx.strokeRect(0.5, 0.5, width - 1, height - 1);
    
    // Top section - Exam name (left) and Session info (right) - with more padding
    const topY = 35; // Increased from 25 to add more padding
    
    // Left side - Exam name
    this.ctx.fillStyle = '#09090b';
    this.ctx.font = 'bold 20px Inter, sans-serif';
    this.ctx.textAlign = 'left';
    this.ctx.fillText(this.currentExam.name, 20, topY);
    
    // Right side - Session and date
    this.ctx.fillStyle = '#52525b';
    this.ctx.font = '14px Inter, sans-serif';
    this.ctx.textAlign = 'right';
    const sessionText = this.currentSession.session || 'Main Session';
    this.ctx.fillText(sessionText, width - 20, topY - 8);
    
    this.ctx.fillStyle = '#71717a';
    this.ctx.font = '12px Inter, sans-serif';
    const dateText = new Date(this.currentSession.date).toLocaleDateString('en-IN', { 
      month: 'short', 
      day: 'numeric',
      year: 'numeric'
    });
    this.ctx.fillText(dateText, width - 20, topY + 8);
    
    // Main countdown section - takes up most of the space
    const countdownStartY = 70; // Adjusted to accommodate new top padding
    const countdownHeight = height - countdownStartY - 40;
    
    // Countdown grid - 4 columns, maximize usage of available space
    const items = [
      { value: days, label: 'DAYS' },
      { value: hours, label: 'HRS' },
      { value: minutes, label: 'MIN' },
      { value: seconds, label: 'SEC' }
    ];
    
    const padding = 10;
    const gridWidth = width - (padding * 2);
    const itemWidth = gridWidth / 4;
    const itemHeight = countdownHeight - 20;
    
    items.forEach((item, index) => {
      const x = padding + (index * itemWidth);
      const centerX = x + (itemWidth / 2);
      const centerY = countdownStartY + (itemHeight / 2);
      
      // Reduced height background for each countdown item
      const itemBoxHeight = itemHeight - 60; // Reduced from itemHeight - 20 to make it more compact
      const itemBoxY = countdownStartY + 20; // Adjusted Y position
      
      // Background for each countdown item
      this.ctx!.fillStyle = 'rgba(0, 0, 0, 0.03)';
      this.ctx!.fillRect(x + 4, itemBoxY, itemWidth - 8, itemBoxHeight);
      
      // Border for each item
      this.ctx!.strokeStyle = 'rgba(0, 0, 0, 0.08)';
      this.ctx!.lineWidth = 1;
      this.ctx!.strokeRect(x + 4.5, itemBoxY + 0.5, itemWidth - 9, itemBoxHeight - 1);
      
      // Large countdown number - centered in the smaller box
      this.ctx!.fillStyle = '#09090b';
      this.ctx!.font = 'bold 48px Inter, sans-serif';
      this.ctx!.textAlign = 'center';
      this.ctx!.fillText(item.value.toString().padStart(2, '0'), centerX, itemBoxY + (itemBoxHeight / 2) + 12);
      
      // Label below the box
      this.ctx!.fillStyle = '#71717a';
      this.ctx!.font = 'bold 11px Inter, sans-serif';
      this.ctx!.fillText(item.label, centerX, itemBoxY + itemBoxHeight + 15);
    });
    
    // Footer - compact branding
    this.ctx.fillStyle = '#a1a1aa';
    this.ctx.font = '9px Inter, sans-serif';
    this.ctx.textAlign = 'center';
    this.ctx.fillText('TimeKeeper', width / 2, height - 8);
  }

  drawExpiredState() {
    if (!this.ctx || !this.canvas) return;
    
    const width = this.canvas.width;
    const height = this.canvas.height;
    
    // Clear with clean white background
    this.ctx.fillStyle = '#ffffff';
    this.ctx.fillRect(0, 0, width, height);
    
    // Add border
    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
    this.ctx.lineWidth = 1;
    this.ctx.strokeRect(0.5, 0.5, width - 1, height - 1);
    
    // Top section - Exam name (left) and Session info (right) - with more padding
    const topY = 35; // Increased from 25 to add more padding
    
    // Left side - Exam name
    this.ctx.fillStyle = '#09090b';
    this.ctx.font = 'bold 20px Inter, sans-serif';
    this.ctx.textAlign = 'left';
    this.ctx.fillText(this.currentExam.name, 20, topY);
    
    // Right side - Session and date
    this.ctx.fillStyle = '#52525b';
    this.ctx.font = '14px Inter, sans-serif';
    this.ctx.textAlign = 'right';
    const sessionText = this.currentSession.session || 'Main Session';
    this.ctx.fillText(sessionText, width - 20, topY - 8);
    
    this.ctx.fillStyle = '#71717a';
    this.ctx.font = '12px Inter, sans-serif';
    const dateText = new Date(this.currentSession.date).toLocaleDateString('en-IN', { 
      month: 'short', 
      day: 'numeric',
      year: 'numeric'
    });
    this.ctx.fillText(dateText, width - 20, topY + 8);
    
    // Center content area
    const centerY = height / 2;
    
    // Large completed message
    this.ctx.fillStyle = '#16a34a';
    this.ctx.font = 'bold 36px Inter, sans-serif';
    this.ctx.textAlign = 'center';
    this.ctx.fillText('‚úì COMPLETED', width / 2, centerY - 20);
    
    // Subtitle
    this.ctx.fillStyle = '#52525b';
    this.ctx.font = '16px Inter, sans-serif';
    this.ctx.fillText('Exam has started/passed', width / 2, centerY + 20);
    
    // Footer
    this.ctx.fillStyle = '#a1a1aa';
    this.ctx.font = '9px Inter, sans-serif';
    this.ctx.fillText('TimeKeeper', width / 2, height - 8);
  }

  showStatusIndicator() {
    const status = document.getElementById('pip-status');
    if (status) {
      status.classList.add('active');
      const statusText = document.getElementById('pip-status-text');
      if (statusText) {
        const examName = this.currentExam.name.length > 12 
          ? this.currentExam.name.substring(0, 12) + '...' 
          : this.currentExam.name;
        statusText.textContent = `${examName} ‚Ä¢ PiP Active`;
      }
    }
  }

  hideStatusIndicator() {
    const status = document.getElementById('pip-status');
    if (status) {
      status.classList.remove('active');
      console.log('PiP status indicator hidden');
    }
  }

  showFallbackNotification(reason?: string) {
    const fallback = document.getElementById('pip-fallback');
    if (fallback) {
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const defaultReason = isMobile 
        ? 'Picture-in-Picture is not supported on mobile devices' 
        : 'Use a desktop browser for the best PiP countdown experience';
      
      const reasonText = reason || defaultReason;
      const icon = isMobile ? 'üì±' : 'üñ•Ô∏è';
      
      fallback.innerHTML = `
        <div style="margin-bottom: 6px; font-weight: 500; display: flex; align-items: center; gap: 6px;">
          <span>${icon}</span>
          <span>PiP Not Available</span>
        </div>
        <div style="font-size: 11px; opacity: 0.8; line-height: 1.4;">${reasonText}</div>
        ${isMobile ? '<div style="font-size: 10px; opacity: 0.6; margin-top: 4px;">Try on desktop Chrome, Firefox, or Safari</div>' : ''}
      `;
      fallback.classList.add('show');
      
      // Auto-hide after longer time for mobile users to read
      const hideDelay = isMobile ? 6000 : 4000;
      setTimeout(() => {
        fallback.classList.remove('show');
      }, hideDelay);
    }
  }

  startUpdating() {
    this.stopUpdating();
    this.updateCountdown();
    this.updateInterval = setInterval(() => this.updateCountdown(), 1000);
  }

  stopUpdating() {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
      this.updateInterval = null;
    }
  }

  // Public API methods
  updateSession(session: any) {
    if (this.isActive) {
      this.currentSession = session;
      this.updateCountdown();
    }
  }
}

// Initialize global PiP countdown
window.pipCountdown = new PictureInPictureCountdown();

// Global functions
window.startPiPCountdown = async (exam: any, session?: any) => {
  return await window.pipCountdown.startPiP(exam, session);
};

window.stopPiPCountdown = async () => {
  await window.pipCountdown.stopPiP();
};

window.closePiP = async () => {
  await window.pipCountdown.stopPiP();
};

// Handle PiP events
document.addEventListener('enterpictureinpicture', () => {
  window.pipCountdown.showStatusIndicator();
});

document.addEventListener('leavepictureinpicture', () => {
  window.pipCountdown.hideStatusIndicator();
  window.pipCountdown.isActive = false;
  window.pipCountdown.stopUpdating();
  
  // Clean up video stream when PiP is closed
  if (window.pipCountdown.video) {
    window.pipCountdown.video.srcObject = null;
    window.pipCountdown.video = null;
  }
  
  if (window.pipCountdown.stream) {
    window.pipCountdown.stream.getTracks().forEach(track => track.stop());
    window.pipCountdown.stream = null;
  }
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && document.pictureInPictureElement) {
    window.closePiP();
  }
});
</script>
